/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export type AssetStruct = {
  pool: PromiseOrValue<string>;
  manager: PromiseOrValue<string>;
  tokenId: PromiseOrValue<BigNumberish>;
  liquidity: PromiseOrValue<BigNumberish>;
  data: PromiseOrValue<BytesLike>;
};

export type AssetStructOutput = [
  string,
  string,
  BigNumber,
  BigNumber,
  string
] & {
  pool: string;
  manager: string;
  tokenId: BigNumber;
  liquidity: BigNumber;
  data: string;
};

export type ProvidedStruct = {
  tokens: PromiseOrValue<string>[];
  amounts: PromiseOrValue<BigNumberish>[];
  nfts: AssetStruct[];
};

export type ProvidedStructOutput = [
  string[],
  BigNumber[],
  AssetStructOutput[]
] & { tokens: string[]; amounts: BigNumber[]; nfts: AssetStructOutput[] };

export type SwapPointStruct = {
  amountIn: PromiseOrValue<BigNumberish>;
  valueIn: PromiseOrValue<BigNumberish>;
  amountOut: PromiseOrValue<BigNumberish>;
  valueOut: PromiseOrValue<BigNumberish>;
  slippage: PromiseOrValue<BigNumberish>;
  tokenIn: PromiseOrValue<string>;
  swappers: PromiseOrValue<string>[];
  tokenOut: PromiseOrValue<string>;
  paths: PromiseOrValue<string>[][];
};

export type SwapPointStructOutput = [
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  string,
  string[],
  string,
  string[][]
] & {
  amountIn: BigNumber;
  valueIn: BigNumber;
  amountOut: BigNumber;
  valueOut: BigNumber;
  slippage: BigNumber;
  tokenIn: string;
  swappers: string[];
  tokenOut: string;
  paths: string[][];
};

export type DesiredStruct = {
  outputERC20s: PromiseOrValue<string>[];
  outputERC721s: AssetStruct[];
  ratios: PromiseOrValue<BigNumberish>[];
  minAmountsOut: PromiseOrValue<BigNumberish>[];
};

export type DesiredStructOutput = [
  string[],
  AssetStructOutput[],
  BigNumber[],
  BigNumber[]
] & {
  outputERC20s: string[];
  outputERC721s: AssetStructOutput[];
  ratios: BigNumber[];
  minAmountsOut: BigNumber[];
};

export type ConversionStruct = {
  desiredERC721: AssetStruct;
  desiredERC20: PromiseOrValue<string>;
  value: PromiseOrValue<BigNumberish>;
  underlying: PromiseOrValue<string>[];
  underlyingValues: PromiseOrValue<BigNumberish>[];
};

export type ConversionStructOutput = [
  AssetStructOutput,
  string,
  BigNumber,
  string[],
  BigNumber[]
] & {
  desiredERC721: AssetStructOutput;
  desiredERC20: string;
  value: BigNumber;
  underlying: string[];
  underlyingValues: BigNumber[];
};

export interface SwapHelperInterface extends utils.Interface {
  functions: {
    "estimateValue((address[],uint256[],(address,address,uint256,uint256,bytes)[]),address)": FunctionFragment;
    "findMultipleSwaps(address[],uint256[],uint256[],address[],uint256[])": FunctionFragment;
    "getAmountsOut((address[],uint256[],(address,address,uint256,uint256,bytes)[]),(address[],(address,address,uint256,uint256,bytes)[],uint256[],uint256[]),(uint256,uint256,uint256,uint256,int256,address,address[],address,address[][])[],((address,address,uint256,uint256,bytes),address,uint256,address[],uint256[])[])": FunctionFragment;
    "getProtocol(address)": FunctionFragment;
    "getSwappers()": FunctionFragment;
    "getTokenValues(address[],uint256[])": FunctionFragment;
    "getUnderlyingERC20(address)": FunctionFragment;
    "getUnderlyingERC721((address,address,uint256,uint256,bytes))": FunctionFragment;
    "isSimpleToken(address)": FunctionFragment;
    "networkToken()": FunctionFragment;
    "nftPoolInteractors(uint256)": FunctionFragment;
    "oracle()": FunctionFragment;
    "owner()": FunctionFragment;
    "poolInteractors(uint256)": FunctionFragment;
    "prepareConversions(address[],(address,address,uint256,uint256,bytes)[],uint256[],uint256)": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "setNFTPoolInteractors(address[])": FunctionFragment;
    "setOracle(address)": FunctionFragment;
    "setPoolInteractors(address[])": FunctionFragment;
    "setSwappers(address[])": FunctionFragment;
    "simplifyWithoutWrite(address[],uint256[],(address,address,uint256,uint256,bytes)[])": FunctionFragment;
    "simulateConversions(((address,address,uint256,uint256,bytes),address,uint256,address[],uint256[])[],address[],address[],uint256[])": FunctionFragment;
    "simulateSwaps((uint256,uint256,uint256,uint256,int256,address,address[],address,address[][])[],address[],uint256[])": FunctionFragment;
    "stableToken()": FunctionFragment;
    "swappers(uint256)": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "estimateValue"
      | "findMultipleSwaps"
      | "getAmountsOut"
      | "getProtocol"
      | "getSwappers"
      | "getTokenValues"
      | "getUnderlyingERC20"
      | "getUnderlyingERC721"
      | "isSimpleToken"
      | "networkToken"
      | "nftPoolInteractors"
      | "oracle"
      | "owner"
      | "poolInteractors"
      | "prepareConversions"
      | "renounceOwnership"
      | "setNFTPoolInteractors"
      | "setOracle"
      | "setPoolInteractors"
      | "setSwappers"
      | "simplifyWithoutWrite"
      | "simulateConversions"
      | "simulateSwaps"
      | "stableToken"
      | "swappers"
      | "transferOwnership"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "estimateValue",
    values: [ProvidedStruct, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "findMultipleSwaps",
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getAmountsOut",
    values: [
      ProvidedStruct,
      DesiredStruct,
      SwapPointStruct[],
      ConversionStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getProtocol",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getSwappers",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenValues",
    values: [PromiseOrValue<string>[], PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "getUnderlyingERC20",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getUnderlyingERC721",
    values: [AssetStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "isSimpleToken",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "networkToken",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "nftPoolInteractors",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "oracle", values?: undefined): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "poolInteractors",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "prepareConversions",
    values: [
      PromiseOrValue<string>[],
      AssetStruct[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setNFTPoolInteractors",
    values: [PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "setOracle",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setPoolInteractors",
    values: [PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "setSwappers",
    values: [PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "simplifyWithoutWrite",
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      AssetStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "simulateConversions",
    values: [
      ConversionStruct[],
      PromiseOrValue<string>[],
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "simulateSwaps",
    values: [
      SwapPointStruct[],
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "stableToken",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "swappers",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [PromiseOrValue<string>]
  ): string;

  decodeFunctionResult(
    functionFragment: "estimateValue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "findMultipleSwaps",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAmountsOut",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getProtocol",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSwappers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenValues",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUnderlyingERC20",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUnderlyingERC721",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isSimpleToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "networkToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nftPoolInteractors",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "oracle", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "poolInteractors",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "prepareConversions",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setNFTPoolInteractors",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setOracle", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setPoolInteractors",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setSwappers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "simplifyWithoutWrite",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "simulateConversions",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "simulateSwaps",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "stableToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "swappers", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;

  events: {
    "OwnershipTransferred(address,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
}

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface SwapHelper extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: SwapHelperInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    estimateValue(
      assets: ProvidedStruct,
      inTermsOf: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    findMultipleSwaps(
      inputTokens: PromiseOrValue<string>[],
      inputAmounts: PromiseOrValue<BigNumberish>[],
      inputValues: PromiseOrValue<BigNumberish>[],
      outputTokens: PromiseOrValue<string>[],
      outputValues: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<
      [SwapPointStructOutput[]] & { bestSwaps: SwapPointStructOutput[] }
    >;

    getAmountsOut(
      provided: ProvidedStruct,
      desired: DesiredStruct,
      swaps: SwapPointStruct[],
      conversions: ConversionStruct[],
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber[]] & {
        amounts: BigNumber[];
        expectedUSDValues: BigNumber[];
      }
    >;

    getProtocol(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getSwappers(overrides?: CallOverrides): Promise<[string[]]>;

    getTokenValues(
      tokens: PromiseOrValue<string>[],
      tokenAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber] & { values: BigNumber[]; total: BigNumber }
    >;

    getUnderlyingERC20(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [string[], BigNumber[]] & {
        underlyingTokens: string[];
        ratios: BigNumber[];
      }
    >;

    getUnderlyingERC721(
      nft: AssetStruct,
      overrides?: CallOverrides
    ): Promise<
      [string[], BigNumber[]] & { underlying: string[]; ratios: BigNumber[] }
    >;

    isSimpleToken(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    networkToken(overrides?: CallOverrides): Promise<[string]>;

    nftPoolInteractors(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    oracle(overrides?: CallOverrides): Promise<[string]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    poolInteractors(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    prepareConversions(
      desiredERC20s: PromiseOrValue<string>[],
      desiredERC721s: AssetStruct[],
      ratios: PromiseOrValue<BigNumberish>[],
      totalAvailable: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [ConversionStructOutput[]] & { conversions: ConversionStructOutput[] }
    >;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setNFTPoolInteractors(
      _nftPoolInteractors: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setOracle(
      _oracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setPoolInteractors(
      _poolInteractors: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setSwappers(
      _swappers: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    simplifyWithoutWrite(
      tokens: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      nfts: AssetStruct[],
      overrides?: CallOverrides
    ): Promise<
      [string[], BigNumber[]] & {
        simplifiedTokens: string[];
        simplifiedAmounts: BigNumber[];
      }
    >;

    simulateConversions(
      conversions: ConversionStruct[],
      outputTokens: PromiseOrValue<string>[],
      inputTokens: PromiseOrValue<string>[],
      inputAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<[BigNumber[]] & { amounts: BigNumber[] }>;

    simulateSwaps(
      swaps: SwapPointStruct[],
      tokens: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<
      [string[], BigNumber[]] & { tokensOut: string[]; amountsOut: BigNumber[] }
    >;

    stableToken(overrides?: CallOverrides): Promise<[string]>;

    swappers(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  estimateValue(
    assets: ProvidedStruct,
    inTermsOf: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  findMultipleSwaps(
    inputTokens: PromiseOrValue<string>[],
    inputAmounts: PromiseOrValue<BigNumberish>[],
    inputValues: PromiseOrValue<BigNumberish>[],
    outputTokens: PromiseOrValue<string>[],
    outputValues: PromiseOrValue<BigNumberish>[],
    overrides?: CallOverrides
  ): Promise<SwapPointStructOutput[]>;

  getAmountsOut(
    provided: ProvidedStruct,
    desired: DesiredStruct,
    swaps: SwapPointStruct[],
    conversions: ConversionStruct[],
    overrides?: CallOverrides
  ): Promise<
    [BigNumber[], BigNumber[]] & {
      amounts: BigNumber[];
      expectedUSDValues: BigNumber[];
    }
  >;

  getProtocol(
    token: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string>;

  getSwappers(overrides?: CallOverrides): Promise<string[]>;

  getTokenValues(
    tokens: PromiseOrValue<string>[],
    tokenAmounts: PromiseOrValue<BigNumberish>[],
    overrides?: CallOverrides
  ): Promise<
    [BigNumber[], BigNumber] & { values: BigNumber[]; total: BigNumber }
  >;

  getUnderlyingERC20(
    token: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [string[], BigNumber[]] & {
      underlyingTokens: string[];
      ratios: BigNumber[];
    }
  >;

  getUnderlyingERC721(
    nft: AssetStruct,
    overrides?: CallOverrides
  ): Promise<
    [string[], BigNumber[]] & { underlying: string[]; ratios: BigNumber[] }
  >;

  isSimpleToken(
    token: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  networkToken(overrides?: CallOverrides): Promise<string>;

  nftPoolInteractors(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  oracle(overrides?: CallOverrides): Promise<string>;

  owner(overrides?: CallOverrides): Promise<string>;

  poolInteractors(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  prepareConversions(
    desiredERC20s: PromiseOrValue<string>[],
    desiredERC721s: AssetStruct[],
    ratios: PromiseOrValue<BigNumberish>[],
    totalAvailable: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<ConversionStructOutput[]>;

  renounceOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setNFTPoolInteractors(
    _nftPoolInteractors: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setOracle(
    _oracle: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setPoolInteractors(
    _poolInteractors: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setSwappers(
    _swappers: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  simplifyWithoutWrite(
    tokens: PromiseOrValue<string>[],
    amounts: PromiseOrValue<BigNumberish>[],
    nfts: AssetStruct[],
    overrides?: CallOverrides
  ): Promise<
    [string[], BigNumber[]] & {
      simplifiedTokens: string[];
      simplifiedAmounts: BigNumber[];
    }
  >;

  simulateConversions(
    conversions: ConversionStruct[],
    outputTokens: PromiseOrValue<string>[],
    inputTokens: PromiseOrValue<string>[],
    inputAmounts: PromiseOrValue<BigNumberish>[],
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  simulateSwaps(
    swaps: SwapPointStruct[],
    tokens: PromiseOrValue<string>[],
    amounts: PromiseOrValue<BigNumberish>[],
    overrides?: CallOverrides
  ): Promise<
    [string[], BigNumber[]] & { tokensOut: string[]; amountsOut: BigNumber[] }
  >;

  stableToken(overrides?: CallOverrides): Promise<string>;

  swappers(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    estimateValue(
      assets: ProvidedStruct,
      inTermsOf: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    findMultipleSwaps(
      inputTokens: PromiseOrValue<string>[],
      inputAmounts: PromiseOrValue<BigNumberish>[],
      inputValues: PromiseOrValue<BigNumberish>[],
      outputTokens: PromiseOrValue<string>[],
      outputValues: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<SwapPointStructOutput[]>;

    getAmountsOut(
      provided: ProvidedStruct,
      desired: DesiredStruct,
      swaps: SwapPointStruct[],
      conversions: ConversionStruct[],
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber[]] & {
        amounts: BigNumber[];
        expectedUSDValues: BigNumber[];
      }
    >;

    getProtocol(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string>;

    getSwappers(overrides?: CallOverrides): Promise<string[]>;

    getTokenValues(
      tokens: PromiseOrValue<string>[],
      tokenAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber] & { values: BigNumber[]; total: BigNumber }
    >;

    getUnderlyingERC20(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [string[], BigNumber[]] & {
        underlyingTokens: string[];
        ratios: BigNumber[];
      }
    >;

    getUnderlyingERC721(
      nft: AssetStruct,
      overrides?: CallOverrides
    ): Promise<
      [string[], BigNumber[]] & { underlying: string[]; ratios: BigNumber[] }
    >;

    isSimpleToken(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    networkToken(overrides?: CallOverrides): Promise<string>;

    nftPoolInteractors(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    oracle(overrides?: CallOverrides): Promise<string>;

    owner(overrides?: CallOverrides): Promise<string>;

    poolInteractors(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    prepareConversions(
      desiredERC20s: PromiseOrValue<string>[],
      desiredERC721s: AssetStruct[],
      ratios: PromiseOrValue<BigNumberish>[],
      totalAvailable: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<ConversionStructOutput[]>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    setNFTPoolInteractors(
      _nftPoolInteractors: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    setOracle(
      _oracle: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setPoolInteractors(
      _poolInteractors: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    setSwappers(
      _swappers: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    simplifyWithoutWrite(
      tokens: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      nfts: AssetStruct[],
      overrides?: CallOverrides
    ): Promise<
      [string[], BigNumber[]] & {
        simplifiedTokens: string[];
        simplifiedAmounts: BigNumber[];
      }
    >;

    simulateConversions(
      conversions: ConversionStruct[],
      outputTokens: PromiseOrValue<string>[],
      inputTokens: PromiseOrValue<string>[],
      inputAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    simulateSwaps(
      swaps: SwapPointStruct[],
      tokens: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<
      [string[], BigNumber[]] & { tokensOut: string[]; amountsOut: BigNumber[] }
    >;

    stableToken(overrides?: CallOverrides): Promise<string>;

    swappers(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "OwnershipTransferred(address,address)"(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
  };

  estimateGas: {
    estimateValue(
      assets: ProvidedStruct,
      inTermsOf: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    findMultipleSwaps(
      inputTokens: PromiseOrValue<string>[],
      inputAmounts: PromiseOrValue<BigNumberish>[],
      inputValues: PromiseOrValue<BigNumberish>[],
      outputTokens: PromiseOrValue<string>[],
      outputValues: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getAmountsOut(
      provided: ProvidedStruct,
      desired: DesiredStruct,
      swaps: SwapPointStruct[],
      conversions: ConversionStruct[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getProtocol(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getSwappers(overrides?: CallOverrides): Promise<BigNumber>;

    getTokenValues(
      tokens: PromiseOrValue<string>[],
      tokenAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getUnderlyingERC20(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getUnderlyingERC721(
      nft: AssetStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isSimpleToken(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    networkToken(overrides?: CallOverrides): Promise<BigNumber>;

    nftPoolInteractors(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    oracle(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    poolInteractors(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    prepareConversions(
      desiredERC20s: PromiseOrValue<string>[],
      desiredERC721s: AssetStruct[],
      ratios: PromiseOrValue<BigNumberish>[],
      totalAvailable: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setNFTPoolInteractors(
      _nftPoolInteractors: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setOracle(
      _oracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setPoolInteractors(
      _poolInteractors: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setSwappers(
      _swappers: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    simplifyWithoutWrite(
      tokens: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      nfts: AssetStruct[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    simulateConversions(
      conversions: ConversionStruct[],
      outputTokens: PromiseOrValue<string>[],
      inputTokens: PromiseOrValue<string>[],
      inputAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    simulateSwaps(
      swaps: SwapPointStruct[],
      tokens: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    stableToken(overrides?: CallOverrides): Promise<BigNumber>;

    swappers(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    estimateValue(
      assets: ProvidedStruct,
      inTermsOf: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    findMultipleSwaps(
      inputTokens: PromiseOrValue<string>[],
      inputAmounts: PromiseOrValue<BigNumberish>[],
      inputValues: PromiseOrValue<BigNumberish>[],
      outputTokens: PromiseOrValue<string>[],
      outputValues: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getAmountsOut(
      provided: ProvidedStruct,
      desired: DesiredStruct,
      swaps: SwapPointStruct[],
      conversions: ConversionStruct[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getProtocol(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getSwappers(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getTokenValues(
      tokens: PromiseOrValue<string>[],
      tokenAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getUnderlyingERC20(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getUnderlyingERC721(
      nft: AssetStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isSimpleToken(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    networkToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nftPoolInteractors(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    oracle(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    poolInteractors(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    prepareConversions(
      desiredERC20s: PromiseOrValue<string>[],
      desiredERC721s: AssetStruct[],
      ratios: PromiseOrValue<BigNumberish>[],
      totalAvailable: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setNFTPoolInteractors(
      _nftPoolInteractors: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setOracle(
      _oracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setPoolInteractors(
      _poolInteractors: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setSwappers(
      _swappers: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    simplifyWithoutWrite(
      tokens: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      nfts: AssetStruct[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    simulateConversions(
      conversions: ConversionStruct[],
      outputTokens: PromiseOrValue<string>[],
      inputTokens: PromiseOrValue<string>[],
      inputAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    simulateSwaps(
      swaps: SwapPointStruct[],
      tokens: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    stableToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    swappers(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
